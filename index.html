<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>æ‰‹æœºä¸“ç”¨ï¼šç…§ç‰‡å¢™ + æåˆé€‰ä¸­æ”¾å¤§</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#06060a; font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif; }
    #app { position:fixed; inset:0; }
    #hud{
      position:fixed; left:12px; top:10px; z-index:50;
      color:rgba(255,255,255,.92); font-size:13px; line-height:1.45;
      padding:10px 12px; border-radius:14px;
      background:rgba(0,0,0,.38); backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.12);
      max-width:min(92vw, 560px);
    }
    #badge{
      display:inline-block; padding:2px 8px; border-radius:999px; margin-right:8px; font-weight:650;
      background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.14);
    }
    #status{ margin-top:6px; opacity:.95; }
    #tips{ margin-top:8px; opacity:.85; }
    #panel{
      position:fixed; left:12px; right:12px; bottom:14px; z-index:60;
      padding:12px; border-radius:18px;
      background:rgba(0,0,0,.40); backdrop-filter: blur(12px);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.92);
    }
    #panel h3{ margin:0 0 8px 0; font-size:18px; font-weight:800; }
    #panel p{ margin:6px 0; font-size:13px; opacity:.9; line-height:1.45; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      appearance:none; border:none; cursor:pointer;
      padding:12px 14px; border-radius:14px;
      background:rgba(255,255,255,.12); color:#fff; font-weight:750;
      border:1px solid rgba(255,255,255,.14);
    }
    button:active{ transform:scale(.99); }
    #video{
      position:fixed; right:10px; bottom:10px; width:190px; aspect-ratio:4/3;
      border-radius:14px; z-index:40; display:none;
      border:1px solid rgba(255,255,255,.16);
      box-shadow:0 16px 40px rgba(0,0,0,.45);
      background:#000;
    }
    #toggleVideo{
      cursor:pointer; user-select:none; display:inline-block; margin-left:8px;
      padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.10);
    }
    #cursorDot{
      position:fixed; width:12px; height:12px; border-radius:50%;
      background:rgba(255,255,255,.85); box-shadow:0 0 0 6px rgba(255,255,255,.10);
      left:-100px; top:-100px; z-index:55; pointer-events:none;
      transform:translate(-50%,-50%);
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><span id="badge">INIT</span>æ‰‹æœºä¸“ç”¨ï¼šç…§ç‰‡å¢™ + æåˆé€‰ä¸­æ”¾å¤§ <span id="toggleVideo">è§†é¢‘</span></div>
    <div id="status">ç­‰å¾…å¼€å§‹â€¦</div>
    <div id="tips">
      âœ‹ å¼ å¼€=ç…§ç‰‡å¢™ï¼› âœŠ æ¡æ‹³=åœ£è¯æ ‘ï¼› ğŸ¤ æåˆ=ç”¨æ‹‡æŒ‡å°–é€‰ä¸­å¹¶æ”¾å¤§ï¼ˆæ¾å¼€é€€å‡ºï¼‰<br/>
      å»ºè®®ï¼šåç½®æ‘„åƒå¤´ï¼Œæ‰‹ç¦»é•œå¤´çº¦ 30â€“60cmã€‚
    </div>
  </div>

  <div id="panel">
    <h3>å¼€å§‹ä½“éªŒ</h3>
    <p>éœ€è¦æ‘„åƒå¤´æƒé™ã€‚iPhone/Safari å¿…é¡»ç”±â€œç‚¹å‡»æŒ‰é’®â€è§¦å‘æˆæƒã€‚</p>
    <p>æ‰“å¼€åï¼šâœ‹ ç…§ç‰‡å¢™ / âœŠ åœ£è¯æ ‘ / ğŸ¤ æåˆé€‰ä¸­æ”¾å¤§</p>
    <div class="row">
      <button id="btnStart">å¼€å§‹ï¼ˆè¯·æ±‚æ‘„åƒå¤´ï¼‰</button>
      <button id="btnStartFront">ç”¨å‰ç½®æ‘„åƒå¤´</button>
    </div>
    <p style="margin-top:10px; opacity:.8;">è‹¥æ— æ³•æˆæƒï¼šè¯·ç”¨ Safari æ— ç—•æ¨¡å¼æ‰“å¼€ï¼Œå¹¶ç¡®è®¤é¡µé¢åœ°å€æ˜¯ httpsã€‚</p>
  </div>

  <video id="video" playsinline muted></video>
  <div id="cursorDot"></div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <!-- MediaPipe Hands (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // ========= å‚æ•°ï¼ˆiPhone æ¨èï¼‰ =========
    const PARAM = {
      cursorSmooth: 0.20,
      pinchThresh: 0.070,       // æ‹‡æŒ‡å°–-é£ŸæŒ‡å°–è·ç¦»é˜ˆå€¼ï¼ˆè¶Šå°è¶Šéš¾è§¦å‘ï¼‰
      openPalmThresh: 0.70,     // å¼ å¼€åˆ¤æ®
      fistThresh: 0.42,         // æ¡æ‹³åˆ¤æ®
      focusScale: 2.15,
      focusSmooth: 0.18,
      idleRotate: 0.0008,
    };

    // ========= DOM =========
    const badgeEl = document.getElementById('badge');
    const statusEl = document.getElementById('status');
    const panelEl  = document.getElementById('panel');
    const videoEl  = document.getElementById('video');
    const dotEl    = document.getElementById('cursorDot');
    const toggleVideoEl = document.getElementById('toggleVideo');
    const btnStart = document.getElementById('btnStart');
    const btnStartFront = document.getElementById('btnStartFront');

    // ========= Three.js åœºæ™¯ =========
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
    renderer.setSize(innerWidth, innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 0, 10);

    const ambient = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(4, 8, 6);
    scene.add(dir);

    const raycaster = new THREE.Raycaster();
    const pointerNDC = new THREE.Vector2(0, 0);

    // ========= ç…§ç‰‡å¢™ =========
    const photoGroup = new THREE.Group();
    scene.add(photoGroup);

    const cards = [];
    const cardCount = 12;
    const loader = new THREE.TextureLoader();
    loader.crossOrigin = "anonymous";

    function makeCard(tex) {
      const geo = new THREE.PlaneGeometry(1.6, 1.1, 1, 1);
      const mat = new THREE.MeshStandardMaterial({
        map: tex,
        roughness: 0.65,
        metalness: 0.05
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = false;
      mesh.receiveShadow = false;

      // ç»†è¾¹æ¡†ï¼ˆç”¨ç¬¬äºŒå±‚å¹³é¢ï¼‰
      const frameGeo = new THREE.PlaneGeometry(1.66, 1.16);
      const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.12 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.z = -0.001;
      mesh.add(frame);

      mesh.userData = {
        basePos: new THREE.Vector3(),
        targetPos: new THREE.Vector3(),
        baseQuat: new THREE.Quaternion(),
        targetQuat: new THREE.Quaternion(),
        baseScale: 1,
        targetScale: 1,
      };
      return mesh;
    }

    function layoutWall() {
      const radius = 4.2;
      for (let i=0;i<cards.length;i++){
        const a = (i / cards.length) * Math.PI * 2;
        const y = ((i % 4) - 1.5) * 1.35;
        const x = Math.cos(a) * radius;
        const z = Math.sin(a) * radius;
        const m = cards[i];
        m.userData.basePos.set(x, y, z);
        m.userData.targetPos.copy(m.userData.basePos);

        // æœå‘ä¸­å¿ƒ
        const look = new THREE.Matrix4().lookAt(
          m.userData.basePos,
          new THREE.Vector3(0, y*0.15, 0),
          new THREE.Vector3(0,1,0)
        );
        m.userData.baseQuat.setFromRotationMatrix(look);
        m.userData.targetQuat.copy(m.userData.baseQuat);
        m.position.copy(m.userData.basePos);
        m.quaternion.copy(m.userData.baseQuat);
        m.scale.setScalar(1);
      }
    }

    // ä½¿ç”¨ picsum å ä½å›¾ï¼ˆä½ å¯æ¢æˆè‡ªå·±çš„å›¾ç‰‡ URLï¼‰
    const seeds = Array.from({length: cardCount}, (_,i)=>`xmas_${i+1}`);
    let loaded = 0;
    seeds.forEach((s, i) => {
      const url = `https://picsum.photos/seed/${encodeURIComponent(s)}/800/560`;
      loader.load(url, (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
        const card = makeCard(tex);
        cards.push(card);
        photoGroup.add(card);
        loaded++;
        if (loaded === cardCount) {
          layoutWall();
        }
      });
    });

    // ========= åœ£è¯æ ‘ï¼ˆç®€åŒ–ç‰ˆï¼‰ =========
    const treeGroup = new THREE.Group();
    treeGroup.visible = false;
    scene.add(treeGroup);

    function buildTree() {
      // æ ‘èº«
      const cone1 = new THREE.Mesh(
        new THREE.ConeGeometry(1.8, 2.6, 24),
        new THREE.MeshStandardMaterial({ color: 0x1f7a3a, roughness: 0.8, metalness: 0.0 })
      );
      cone1.position.y = 0.3;

      const cone2 = new THREE.Mesh(
        new THREE.ConeGeometry(1.3, 2.1, 24),
        new THREE.MeshStandardMaterial({ color: 0x1c6d33, roughness: 0.8, metalness: 0.0 })
      );
      cone2.position.y = 1.55;

      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.28, 0.32, 1.0, 20),
        new THREE.MeshStandardMaterial({ color: 0x6b3f1f, roughness: 0.9, metalness: 0.0 })
      );
      trunk.position.y = -1.15;

      treeGroup.add(cone1, cone2, trunk);

      // å½©ç¯
      const bulbGeo = new THREE.SphereGeometry(0.10, 14, 14);
      for (let i=0;i<20;i++){
        const m = new THREE.Mesh(
          bulbGeo,
          new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(i/20, 0.9, 0.6), roughness: 0.3, metalness: 0.1, emissive: new THREE.Color().setHSL(i/20, 0.9, 0.3), emissiveIntensity: 0.8 })
        );
        const a = i/20 * Math.PI*2;
        const r = 1.2 - (i%5)*0.15;
        m.position.set(Math.cos(a)*r, (i%10)*0.22 - 0.2, Math.sin(a)*r);
        treeGroup.add(m);
      }

      // æ˜Ÿæ˜Ÿ
      const star = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.22, 0),
        new THREE.MeshStandardMaterial({ color: 0xffdd66, emissive: 0xffcc33, emissiveIntensity: 1.0, roughness: 0.25 })
      );
      star.position.set(0, 2.55, 0);
      treeGroup.add(star);
    }
    buildTree();

    // ========= æ‰‹åŠ¿çŠ¶æ€ =========
    let mode = "INIT"; // INIT | WALL | TREE | FOCUS
    let focused = null;

    // cursorï¼ˆå±å¹•åæ ‡ï¼‰
    let cursorX = innerWidth * 0.5;
    let cursorY = innerHeight * 0.5;
    let cursorVis = false;

    function setMode(m) {
      if (mode === m) return;
      mode = m;
      badgeEl.textContent = m;
      if (m === "WALL") {
        photoGroup.visible = true;
        treeGroup.visible = false;
        statusEl.textContent = "ç…§ç‰‡å¢™æ¨¡å¼ï¼šå¼ å¼€æ‰‹ä¿æŒï¼›æåˆå¯é€‰ä¸­æ”¾å¤§";
      } else if (m === "TREE") {
        photoGroup.visible = false;
        treeGroup.visible = true;
        statusEl.textContent = "åœ£è¯æ ‘æ¨¡å¼ï¼šæ¡æ‹³ä¿æŒï¼›å¼ å¼€å›ç…§ç‰‡å¢™";
      } else if (m === "FOCUS") {
        photoGroup.visible = true;
        treeGroup.visible = false;
        statusEl.textContent = "å·²é€‰ä¸­ï¼šæ¾å¼€æåˆé€€å‡º";
      } else {
        photoGroup.visible = true;
        treeGroup.visible = false;
        statusEl.textContent = "ç­‰å¾…å¼€å§‹â€¦";
      }
    }

    function smoothTo(a, b, t){ return a + (b-a)*t; }

    function setCursor(nx, ny) {
      // nx, ny: 0..1
      const x = nx * innerWidth;
      const y = ny * innerHeight;
      cursorX = smoothTo(cursorX, x, PARAM.cursorSmooth);
      cursorY = smoothTo(cursorY, y, PARAM.cursorSmooth);
      dotEl.style.left = cursorX + "px";
      dotEl.style.top  = cursorY + "px";
      cursorVis = true;
    }

    function hideCursor() {
      cursorVis = false;
      dotEl.style.left = "-100px";
      dotEl.style.top  = "-100px";
    }

    function landmarkDist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dz = (a.z || 0) - (b.z || 0);
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    // å¼ å¼€/æ¡æ‹³ç²—åˆ¤ï¼ˆç”¨æŒ‡å°–åˆ°æŒå¿ƒçš„è·ç¦»ï¼‰
    function openness(lm) {
      const palm = lm[0]; // wrist
      const tips = [4,8,12,16,20].map(i=>lm[i]);
      const ds = tips.map(t=>landmarkDist(palm, t));
      // ç»éªŒï¼šè¶Šå¤§è¶Šå¼ å¼€
      const avg = ds.reduce((s,v)=>s+v,0)/ds.length;
      return avg; // ~0.35..0.9
    }

    function getPinch(lm){
      const thumb = lm[4];
      const index = lm[8];
      return landmarkDist(thumb, index);
    }

    function focusCardByCursor() {
      // cursor -> NDC
      pointerNDC.x = (cursorX / innerWidth) * 2 - 1;
      pointerNDC.y = -(cursorY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointerNDC, camera);
      const hits = raycaster.intersectObjects(cards, true);
      if (hits && hits.length) {
        let obj = hits[0].object;
        // å¦‚æœç‚¹åˆ° frame å­ç‰©ä½“ï¼Œå‘ä¸Šæ‰¾åˆ° card
        while (obj && !cards.includes(obj) && obj.parent) obj = obj.parent;
        if (obj && cards.includes(obj)) return obj;
      }
      return null;
    }

    function enterFocus(card) {
      focused = card;
      setMode("FOCUS");
      // è®©è¿™ä¸ªå¡ç‰‡ç§»åŠ¨åˆ°é•œå¤´å‰
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const target = new THREE.Vector3().copy(camera.position).add(forward.multiplyScalar(3.2));
      card.userData.targetPos.copy(target);
      // æœå‘é•œå¤´
      const look = new THREE.Matrix4().lookAt(target, camera.position, new THREE.Vector3(0,1,0));
      card.userData.targetQuat.setFromRotationMatrix(look);
      card.userData.targetScale = PARAM.focusScale;
    }

    function exitFocus() {
      if (!focused) return;
      // æ¢å¤å¸ƒå±€
      focused.userData.targetPos.copy(focused.userData.basePos);
      focused.userData.targetQuat.copy(focused.userData.baseQuat);
      focused.userData.targetScale = 1;
      focused = null;
      setMode("WALL");
    }

    // ========= MediaPipe Hands =========
    let hands = null;
    let mpCamera = null;
    let lastHandSeen = 0;

    function initHands() {
      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.65,
        minTrackingConfidence: 0.60,
      });
      hands.onResults(onResults);
    }

    function onResults(results) {
      const now = performance.now();
      const lm = results.multiHandLandmarks && results.multiHandLandmarks[0];
      if (!lm) {
        if (now - lastHandSeen > 600) hideCursor();
        return;
      }
      lastHandSeen = now;

      // ä»¥é£ŸæŒ‡æŒ‡å°–åšå…‰æ ‡
      const idxTip = lm[8];
      setCursor(idxTip.x, idxTip.y);

      // æ‰‹åŠ¿åˆ¤å®š
      const open = openness(lm);
      const pinch = getPinch(lm);

      // æ¨¡å¼åˆ‡æ¢ï¼šå¼ å¼€->ç…§ç‰‡å¢™ / æ¡æ‹³->æ ‘
      if (open > PARAM.openPalmThresh) {
        if (mode !== "FOCUS") setMode("WALL");
      } else if (open < PARAM.fistThresh) {
        if (mode !== "FOCUS") setMode("TREE");
      }

      // æåˆé€‰ä¸­ï¼šä»…åœ¨ WALL/FOCUS ç”Ÿæ•ˆ
      if (mode === "WALL" || mode === "FOCUS") {
        if (pinch < PARAM.pinchThresh) {
          if (mode !== "FOCUS") {
            const c = focusCardByCursor();
            if (c) enterFocus(c);
          }
        } else {
          if (mode === "FOCUS") {
            exitFocus();
          }
        }
      }
    }

    // ========= æ‘„åƒå¤´ï¼šiOS/Safari å¿…é¡»â€œåŒæ­¥ onclick ç¬¬ä¸€å±‚è§¦å‘â€ =========
    let stream = null;

    function stopStream() {
      if (!stream) return;
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    }

    function requestCamera(facingMode) {
      // å…³é”®ï¼šä¸è¦ async/awaitï¼Œä¸è¦åŒ…å¤ªæ·±å±‚
      navigator.mediaDevices.getUserMedia({
        video: { facingMode: facingMode },
        audio: false
      }).then(s => {
        stream = s;
        videoEl.srcObject = stream;

        // iOS éœ€è¦ playsinline + ç”¨æˆ·æ‰‹åŠ¿å play
        videoEl.play().then(() => {
          panelEl.style.display = "none";
          setMode("WALL");

          if (!hands) initHands();

          // ç”¨ camera_utils é©±åŠ¨ mediapipe
          if (mpCamera) {
            mpCamera.stop();
            mpCamera = null;
          }
          mpCamera = new Camera(videoEl, {
            onFrame: async () => {
              if (!hands) return;
              await hands.send({ image: videoEl });
            },
            width: 640,
            height: 480
          });
          mpCamera.start();

          statusEl.textContent = "æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œè¯†åˆ«ä¸­â€¦ï¼ˆå¼ å¼€=ç…§ç‰‡å¢™ï¼Œæ¡æ‹³=åœ£è¯æ ‘ï¼Œæåˆ=æ”¾å¤§ï¼‰";
        }).catch(err => {
          alert("è§†é¢‘æ— æ³•æ’­æ”¾ï¼šè¯·ç¡®è®¤å·²å…è®¸æ‘„åƒå¤´ï¼Œå¹¶ä½¿ç”¨ Safari æ‰“å¼€ã€‚");
          console.error(err);
        });
      }).catch(err => {
        alert("æ‘„åƒå¤´æƒé™æœªæˆåŠŸè§¦å‘ï¼šè¯·åœ¨ iPhone è®¾ç½®â†’Safariâ†’æ‘„åƒå¤´ é‡Œå…è®¸ï¼Œå¹¶ç”¨æ— ç—•æ¨¡å¼é‡è¯•ã€‚");
        console.error(err);
      });
    }

    // âœ… iOS å…³é”®ï¼šonclick å¿…é¡»åŒæ­¥è§¦å‘ requestCamera
    btnStart.onclick = () => requestCamera({ ideal: "environment" });
    btnStartFront.onclick = () => requestCamera("user");

    // è§†é¢‘é¢„è§ˆå¼€å…³
    toggleVideoEl.onclick = () => {
      videoEl.style.display = (videoEl.style.display === "none" ? "block" : "none");
    };

    // ========= åŠ¨ç”»ä¸æ’å€¼ =========
    function lerpScene() {
      // ç…§ç‰‡å¢™ç¼“æ…¢æ—‹è½¬
      if (mode === "WALL") {
        scene.rotation.y += PARAM.idleRotate;
      } else if (mode === "TREE") {
        treeGroup.rotation.y += 0.012;
      }

      // å¡ç‰‡æ’å€¼
      for (const card of cards) {
        const isFocus = (card === focused);
        const smooth = isFocus ? PARAM.focusSmooth : 0.10;
        card.position.lerp(card.userData.targetPos, smooth);
        card.quaternion.slerp(card.userData.targetQuat, smooth);
        const tScale = isFocus ? card.userData.targetScale : 1;
        const s = card.scale.x + (tScale - card.scale.x) * smooth;
        card.scale.setScalar(s);
      }
    }

    function tick() {
      requestAnimationFrame(tick);
      lerpScene();
      renderer.render(scene, camera);
    }
    tick();

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
      renderer.setSize(innerWidth, innerHeight);
    });

    // åˆå§‹çŠ¶æ€
    setMode("INIT");
  </script>
</body>
</html>
