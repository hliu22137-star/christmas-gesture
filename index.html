<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>æ‰‹æœºä¸“ç”¨ï¼šç…§ç‰‡å¢™ + æåˆé€‰ä¸­æ”¾å¤§</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#06060a; font-family:system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Microsoft YaHei",sans-serif; }
    #app { position:fixed; inset:0; }
    #hud{
      position:fixed; left:12px; top:10px; z-index:50;
      color:rgba(255,255,255,.92); font-size:13px; line-height:1.45;
      padding:10px 12px; border-radius:14px;
      background:rgba(0,0,0,.38); backdrop-filter: blur(10px);
      border:1px solid rgba(255,255,255,.12);
      max-width:min(92vw, 560px);
    }
    #badge{
      display:inline-block; padding:2px 8px; border-radius:999px; margin-right:8px; font-weight:650;
      background:rgba(255,255,255,.12); border:1px solid rgba(255,255,255,.14);
    }
    #status{ margin-top:6px; opacity:.95; }
    #tips{ margin-top:8px; opacity:.85; }
    #panel{
      position:fixed; left:12px; right:12px; bottom:14px; z-index:60;
      padding:12px; border-radius:18px;
      background:rgba(0,0,0,.40); backdrop-filter: blur(12px);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.92);
    }
    #panel h3{ margin:0 0 8px 0; font-size:18px; font-weight:800; }
    #panel p{ margin:6px 0; font-size:13px; opacity:.9; line-height:1.45; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      appearance:none; border:none; cursor:pointer;
      padding:12px 14px; border-radius:14px;
      background:rgba(255,255,255,.12); color:#fff; font-weight:750;
      border:1px solid rgba(255,255,255,.14);
    }
    button:active{ transform:scale(.99); }
    #video{
      position:fixed; right:10px; bottom:10px; width:190px; aspect-ratio:4/3;
      border-radius:14px; z-index:40; display:none;
      border:1px solid rgba(255,255,255,.16);
      box-shadow:0 16px 40px rgba(0,0,0,.45);
      background:#000;
    }
    #toggleVideo{
      cursor:pointer; user-select:none; display:inline-block; margin-left:8px;
      padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.10);
    }
    #cursorDot{
      position:fixed; width:12px; height:12px; border-radius:50%;
      background:rgba(255,255,255,.85); box-shadow:0 0 0 6px rgba(255,255,255,.10);
      left:-100px; top:-100px; z-index:55; pointer-events:none;
      transform:translate(-50%,-50%);
    }
  </style>
</head>
<body>
  <div id="app"></div>

  <div id="hud">
    <div><span id="badge">INIT</span>æ‰‹æœºä¸“ç”¨ï¼šç…§ç‰‡å¢™ + æåˆé€‰ä¸­æ”¾å¤§ <span id="toggleVideo">è§†é¢‘</span></div>
    <div id="status">ç­‰å¾…å¼€å§‹â€¦</div>
    <div id="tips">
      âœ‹ å¼ å¼€=ç…§ç‰‡å¢™ï¼› âœŠ æ¡æ‹³=åœ£è¯æ ‘ï¼› ğŸ¤ æåˆ=ç”¨æ‹‡æŒ‡å°–é€‰ä¸­å¹¶æ”¾å¤§ï¼ˆæ¾å¼€é€€å‡ºï¼‰<br/>
      å»ºè®®ï¼šåç½®æ‘„åƒå¤´ï¼Œæ‰‹ç¦»é•œå¤´çº¦ 30â€“60cmã€‚
    </div>
  </div>

  <div id="panel">
    <h3>å¼€å§‹ä½“éªŒ</h3>
    <p>éœ€è¦æ‘„åƒå¤´æƒé™ã€‚iPhone/Safari å¿…é¡»ç”±â€œç‚¹å‡»æŒ‰é’®â€è§¦å‘æˆæƒã€‚</p>
    <p>æ‰“å¼€åï¼šâœ‹ ç…§ç‰‡å¢™ / âœŠ åœ£è¯æ ‘ / ğŸ¤ æåˆé€‰ä¸­æ”¾å¤§</p>
    <div class="row">
      <button id="btnStart">å¼€å§‹ï¼ˆè¯·æ±‚æ‘„åƒå¤´ï¼‰</button>
      <button id="btnStartFront">ç”¨å‰ç½®æ‘„åƒå¤´</button>
    </div>
    <p style="margin-top:10px; opacity:.8;">è‹¥æ— æ³•æˆæƒï¼šè¯·ç”¨ Safari æ— ç—•æ¨¡å¼æ‰“å¼€ï¼Œå¹¶ç¡®è®¤é¡µé¢åœ°å€æ˜¯ httpsã€‚</p>
  </div>

  <video id="video" playsinline muted></video>
  <div id="cursorDot"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    const PARAM = {
      cursorSmooth: 0.20,
      pinchThresh: 0.070,
      openPalmThresh: 0.70,
      fistThresh: 0.42,
      focusScale: 2.15,
      focusSmooth: 0.18,
      idleRotate: 0.0008,
      // ç²’å­
      snowCount: 1400,
      snowArea: { x: 10, y: 12, z: 10 },
      snowSpeed: 0.9,
      // ç¯å…‰é—ªçƒ
      twinkleSpeed: 1.6
    };

    const badgeEl = document.getElementById('badge');
    const statusEl = document.getElementById('status');
    const panelEl  = document.getElementById('panel');
    const videoEl  = document.getElementById('video');
    const dotEl    = document.getElementById('cursorDot');
    const toggleVideoEl = document.getElementById('toggleVideo');
    const btnStart = document.getElementById('btnStart');
    const btnStartFront = document.getElementById('btnStartFront');

    // Three.js
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
    renderer.setSize(innerWidth, innerHeight);
    app.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 300);
    camera.position.set(0, 0, 10);

    const ambient = new THREE.AmbientLight(0xffffff, 1.0);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 1.1);
    dir.position.set(4, 8, 6);
    scene.add(dir);

    // è½»é›¾åŒ–ï¼Œè®©ç²’å­æ›´æœ‰å±‚æ¬¡
    scene.fog = new THREE.Fog(0x06060a, 10, 28);

    const raycaster = new THREE.Raycaster();
    const pointerNDC = new THREE.Vector2(0, 0);

    // ç…§ç‰‡å¢™
    const photoGroup = new THREE.Group();
    scene.add(photoGroup);

    const cards = [];
    const cardCount = 12;
    const loader = new THREE.TextureLoader();
    loader.crossOrigin = "anonymous";

    function makeCard(tex) {
      const geo = new THREE.PlaneGeometry(1.6, 1.1, 1, 1);
      const mat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.65, metalness: 0.05 });
      const mesh = new THREE.Mesh(geo, mat);

      const frameGeo = new THREE.PlaneGeometry(1.66, 1.16);
      const frameMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent:true, opacity:0.12 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.z = -0.001;
      mesh.add(frame);

      mesh.userData = {
        basePos: new THREE.Vector3(),
        targetPos: new THREE.Vector3(),
        baseQuat: new THREE.Quaternion(),
        targetQuat: new THREE.Quaternion(),
        targetScale: 1,
      };
      return mesh;
    }

    function layoutWall() {
      const radius = 4.2;
      for (let i=0;i<cards.length;i++){
        const a = (i / cards.length) * Math.PI * 2;
        const y = ((i % 4) - 1.5) * 1.35;
        const x = Math.cos(a) * radius;
        const z = Math.sin(a) * radius;
        const m = cards[i];
        m.userData.basePos.set(x, y, z);
        m.userData.targetPos.copy(m.userData.basePos);

        const look = new THREE.Matrix4().lookAt(
          m.userData.basePos,
          new THREE.Vector3(0, y*0.15, 0),
          new THREE.Vector3(0,1,0)
        );
        m.userData.baseQuat.setFromRotationMatrix(look);
        m.userData.targetQuat.copy(m.userData.baseQuat);
        m.position.copy(m.userData.basePos);
        m.quaternion.copy(m.userData.baseQuat);
        m.scale.setScalar(1);
      }
    }

    const seeds = Array.from({length: cardCount}, (_,i)=>`xmas_${i+1}`);
    let loaded = 0;
    seeds.forEach((s) => {
      const url = `https://picsum.photos/seed/${encodeURIComponent(s)}/800/560`;
      loader.load(url, (tex) => {
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy());
        const card = makeCard(tex);
        cards.push(card);
        photoGroup.add(card);
        loaded++;
        if (loaded === cardCount) layoutWall();
      });
    });

    // ========= åœ£è¯æ ‘ï¼ˆå‡çº§ç‰ˆï¼šæ˜Ÿå…‰ + ç¯å…‰å‘¼å¸ + æ‘‡æ‘†ï¼‰ =========
    const treeGroup = new THREE.Group();
    treeGroup.visible = false;
    scene.add(treeGroup);

    let bulbs = [];
    let starMat = null;
    let starGlow = null;

    function buildTreeFancy() {
      const cone1 = new THREE.Mesh(
        new THREE.ConeGeometry(1.9, 2.7, 40, 1),
        new THREE.MeshStandardMaterial({ color: 0x1f7a3a, roughness: 0.78, metalness: 0.02 })
      );
      cone1.position.y = 0.25;

      const cone2 = new THREE.Mesh(
        new THREE.ConeGeometry(1.35, 2.2, 40, 1),
        new THREE.MeshStandardMaterial({ color: 0x1c6d33, roughness: 0.78, metalness: 0.02 })
      );
      cone2.position.y = 1.55;

      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.30, 0.34, 1.05, 24),
        new THREE.MeshStandardMaterial({ color: 0x6b3f1f, roughness: 0.92, metalness: 0.0 })
      );
      trunk.position.y = -1.18;

      treeGroup.add(cone1, cone2, trunk);

      // ç¯ä¸²ï¼ˆåšæˆä¸€åœˆä¸€åœˆç»•æ ‘ï¼‰
      bulbs = [];
      const bulbGeo = new THREE.SphereGeometry(0.11, 18, 18);

      const rings = [
        { y: 0.95, r: 1.05, n: 14 },
        { y: 0.25, r: 1.35, n: 16 },
        { y: -0.45, r: 1.55, n: 18 },
      ];

      let idx = 0;
      for (const ring of rings) {
        for (let i=0;i<ring.n;i++) {
          const t = i / ring.n * Math.PI * 2;
          const hue = (idx % 20) / 20;
          const base = new THREE.Color().setHSL(hue, 0.9, 0.60);
          const emiss = new THREE.Color().setHSL(hue, 0.9, 0.35);

          const mat = new THREE.MeshStandardMaterial({
            color: base,
            roughness: 0.22,
            metalness: 0.12,
            emissive: emiss,
            emissiveIntensity: 0.6
          });

          const b = new THREE.Mesh(bulbGeo, mat);
          // ç»•æ ‘ä¸€åœˆï¼ŒåŒæ—¶è½»å¾®ä¸Šä¸‹èµ·ä¼
          b.position.set(Math.cos(t)*ring.r, ring.y + Math.sin(t*2)*0.06, Math.sin(t)*ring.r);
          b.userData.tw = Math.random() * Math.PI * 2;
          bulbs.push(b);
          treeGroup.add(b);
          idx++;
        }
      }

      // æ˜Ÿæ˜Ÿï¼šä¸»ä½“ + å…‰æ™•ï¼ˆä¸€ä¸ªåŠé€æ˜çƒï¼‰
      const star = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.25, 0),
        new THREE.MeshStandardMaterial({
          color: 0xffdd66,
          emissive: 0xffcc33,
          emissiveIntensity: 1.2,
          roughness: 0.25,
          metalness: 0.15
        })
      );
      star.position.set(0, 2.58, 0);
      starMat = star.material;
      treeGroup.add(star);

      const glow = new THREE.Mesh(
        new THREE.SphereGeometry(0.55, 20, 20),
        new THREE.MeshBasicMaterial({ color: 0xffcc55, transparent: true, opacity: 0.12 })
      );
      glow.position.copy(star.position);
      starGlow = glow.material;
      treeGroup.add(glow);
    }
    buildTreeFancy();

    // ========= ç²’å­ï¼šé£˜é›ªï¼ˆPointsï¼‰ =========
    const snowGroup = new THREE.Group();
    snowGroup.visible = true;
    scene.add(snowGroup);

    const snowGeom = new THREE.BufferGeometry();
    const snowPos = new Float32Array(PARAM.snowCount * 3);
    const snowVel = new Float32Array(PARAM.snowCount);

    function rand(min, max){ return min + Math.random()*(max-min); }

    for (let i=0;i<PARAM.snowCount;i++){
      const ix = i*3;
      snowPos[ix+0] = rand(-PARAM.snowArea.x, PARAM.snowArea.x);
      snowPos[ix+1] = rand(-PARAM.snowArea.y, PARAM.snowArea.y);
      snowPos[ix+2] = rand(-PARAM.snowArea.z, PARAM.snowArea.z);
      snowVel[i] = rand(0.35, 1.0);
    }
    snowGeom.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));

    // åœ†ç‚¹ç²¾çµ
    const snowMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.06,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.75,
      depthWrite: false
    });

    const snow = new THREE.Points(snowGeom, snowMat);
    snowGroup.add(snow);

    // ========= æ‰‹åŠ¿çŠ¶æ€ =========
    let mode = "INIT"; // INIT | WALL | TREE | FOCUS
    let focused = null;

    let cursorX = innerWidth * 0.5;
    let cursorY = innerHeight * 0.5;

    function setMode(m) {
      if (mode === m) return;
      mode = m;
      badgeEl.textContent = m;

      if (m === "WALL") {
        photoGroup.visible = true;
        treeGroup.visible = false;
        statusEl.textContent = "ç…§ç‰‡å¢™æ¨¡å¼ï¼šå¼ å¼€æ‰‹ä¿æŒï¼›æåˆå¯é€‰ä¸­æ”¾å¤§";
      } else if (m === "TREE") {
        photoGroup.visible = false;
        treeGroup.visible = true;
        statusEl.textContent = "åœ£è¯æ ‘æ¨¡å¼ï¼šæ¡æ‹³ä¿æŒï¼›å¼ å¼€å›ç…§ç‰‡å¢™";
      } else if (m === "FOCUS") {
        photoGroup.visible = true;
        treeGroup.visible = false;
        statusEl.textContent = "å·²é€‰ä¸­ï¼šæ¾å¼€æåˆé€€å‡º";
      } else {
        photoGroup.visible = true;
        treeGroup.visible = false;
        statusEl.textContent = "ç­‰å¾…å¼€å§‹â€¦";
      }
    }

    function smoothTo(a, b, t){ return a + (b-a)*t; }

    function setCursor(nx, ny) {
      const x = nx * innerWidth;
      const y = ny * innerHeight;
      cursorX = smoothTo(cursorX, x, PARAM.cursorSmooth);
      cursorY = smoothTo(cursorY, y, PARAM.cursorSmooth);
      dotEl.style.left = cursorX + "px";
      dotEl.style.top  = cursorY + "px";
    }

    function hideCursor() {
      dotEl.style.left = "-100px";
      dotEl.style.top  = "-100px";
    }

    function landmarkDist(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      const dz = (a.z || 0) - (b.z || 0);
      return Math.sqrt(dx*dx + dy*dy + dz*dz);
    }

    function openness(lm) {
      const palm = lm[0];
      const tips = [4,8,12,16,20].map(i=>lm[i]);
      const ds = tips.map(t=>landmarkDist(palm, t));
      return ds.reduce((s,v)=>s+v,0)/ds.length;
    }

    function getPinch(lm){
      return landmarkDist(lm[4], lm[8]);
    }

    function focusCardByCursor() {
      pointerNDC.x = (cursorX / innerWidth) * 2 - 1;
      pointerNDC.y = -(cursorY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(pointerNDC, camera);
      const hits = raycaster.intersectObjects(cards, true);
      if (hits && hits.length) {
        let obj = hits[0].object;
        while (obj && !cards.includes(obj) && obj.parent) obj = obj.parent;
        if (obj && cards.includes(obj)) return obj;
      }
      return null;
    }

    function enterFocus(card) {
      focused = card;
      setMode("FOCUS");
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
      const target = new THREE.Vector3().copy(camera.position).add(forward.multiplyScalar(3.2));
      card.userData.targetPos.copy(target);

      const look = new THREE.Matrix4().lookAt(target, camera.position, new THREE.Vector3(0,1,0));
      card.userData.targetQuat.setFromRotationMatrix(look);
      card.userData.targetScale = 2.15;
    }

    function exitFocus() {
      if (!focused) return;
      focused.userData.targetPos.copy(focused.userData.basePos);
      focused.userData.targetQuat.copy(focused.userData.baseQuat);
      focused.userData.targetScale = 1;
      focused = null;
      setMode("WALL");
    }

    // ========= MediaPipe Hands =========
    let hands = null;
    let mpCamera = null;
    let lastHandSeen = 0;

    function initHands() {
      hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.65,
        minTrackingConfidence: 0.60,
      });
      hands.onResults(onResults);
    }

    function onResults(results) {
      const now = performance.now();
      const lm = results.multiHandLandmarks && results.multiHandLandmarks[0];
      if (!lm) { if (now - lastHandSeen > 600) hideCursor(); return; }
      lastHandSeen = now;

      const idxTip = lm[8];
      setCursor(idxTip.x, idxTip.y);

      const open = openness(lm);
      const pinch = getPinch(lm);

      if (open > PARAM.openPalmThresh) {
        if (mode !== "FOCUS") setMode("WALL");
      } else if (open < PARAM.fistThresh) {
        if (mode !== "FOCUS") setMode("TREE");
      }

      if (mode === "WALL" || mode === "FOCUS") {
        if (pinch < PARAM.pinchThresh) {
          if (mode !== "FOCUS") {
            const c = focusCardByCursor();
            if (c) enterFocus(c);
          }
        } else {
          if (mode === "FOCUS") exitFocus();
        }
      }
    }

    // ========= æ‘„åƒå¤´ï¼ˆiOS å…³é”®ï¼šåŒæ­¥ onclick ç¬¬ä¸€å±‚è§¦å‘ï¼‰ =========
    let stream = null;

    function requestCamera(facingMode) {
      navigator.mediaDevices.getUserMedia({
        video: { facingMode: facingMode },
        audio: false
      }).then(s => {
        stream = s;
        videoEl.srcObject = stream;

        videoEl.play().then(() => {
          panelEl.style.display = "none";
          setMode("WALL");

          if (!hands) initHands();

          if (mpCamera) { mpCamera.stop(); mpCamera = null; }
          mpCamera = new Camera(videoEl, {
            onFrame: async () => { await hands.send({ image: videoEl }); },
            width: 640,
            height: 480
          });
          mpCamera.start();

          statusEl.textContent = "æ‘„åƒå¤´å·²å¯åŠ¨ï¼Œè¯†åˆ«ä¸­â€¦ï¼ˆå¼ å¼€=ç…§ç‰‡å¢™ï¼Œæ¡æ‹³=åœ£è¯æ ‘ï¼Œæåˆ=æ”¾å¤§ï¼‰";
        }).catch(err => {
          alert("è§†é¢‘æ— æ³•æ’­æ”¾ï¼šè¯·ç¡®è®¤å·²å…è®¸æ‘„åƒå¤´ï¼Œå¹¶ä½¿ç”¨ Safari æ‰“å¼€ã€‚");
          console.error(err);
        });
      }).catch(err => {
        alert("æ‘„åƒå¤´æƒé™æœªæˆåŠŸè§¦å‘ï¼šè¯·åœ¨ iPhone è®¾ç½®â†’Safariâ†’æ‘„åƒå¤´ é‡Œå…è®¸ï¼Œå¹¶ç”¨æ— ç—•æ¨¡å¼é‡è¯•ã€‚");
        console.error(err);
      });
    }

    btnStart.onclick = () => requestCamera({ ideal: "environment" });
    btnStartFront.onclick = () => requestCamera("user");

    toggleVideoEl.onclick = () => {
      videoEl.style.display = (videoEl.style.display === "none" ? "block" : "none");
    };

    // ========= åŠ¨ç”» =========
    function updateSnow(dt) {
      const p = snowGeom.attributes.position.array;
      for (let i=0;i<PARAM.snowCount;i++){
        const ix = i*3;
        // ä¸‹è½ + æ¨ªå‘æ¼‚ç§»
        p[ix+1] -= dt * PARAM.snowSpeed * snowVel[i];
        p[ix+0] += dt * 0.18 * Math.sin((performance.now()*0.001) + i);
        p[ix+2] += dt * 0.10 * Math.cos((performance.now()*0.0012) + i*0.7);

        if (p[ix+1] < -PARAM.snowArea.y) {
          p[ix+1] = PARAM.snowArea.y;
          p[ix+0] = rand(-PARAM.snowArea.x, PARAM.snowArea.x);
          p[ix+2] = rand(-PARAM.snowArea.z, PARAM.snowArea.z);
        }
      }
      snowGeom.attributes.position.needsUpdate = true;
      snow.rotation.y += dt * 0.05;
    }

    function updateTreeFX(t) {
      if (!treeGroup.visible) return;

      // è½»å¾®æ‘‡æ‘†
      treeGroup.rotation.y += 0.012;
      treeGroup.rotation.z = Math.sin(t*0.7) * 0.03;
      treeGroup.position.y = Math.sin(t*0.9) * 0.06;

      // å½©ç¯å‘¼å¸é—ªçƒï¼ˆemissiveIntensityï¼‰
      for (let i=0;i<bulbs.length;i++){
        const b = bulbs[i];
        const k = 0.45 + 0.55 * (0.5 + 0.5*Math.sin(t*PARAM.twinkleSpeed + b.userData.tw));
        b.material.emissiveIntensity = 0.35 + 0.95*k;
        // è½»å¾®å¤§å°å‘¼å¸
        const s = 1.0 + 0.10 * Math.sin(t*1.3 + b.userData.tw);
        b.scale.setScalar(s);
      }

      // æ˜Ÿæ˜Ÿæ›´äº®ä¸€ç‚¹ + å…‰æ™•å‘¼å¸
      if (starMat) {
        starMat.emissiveIntensity = 1.0 + 0.9*(0.5 + 0.5*Math.sin(t*2.1));
      }
      if (starGlow) {
        starGlow.opacity = 0.08 + 0.12*(0.5 + 0.5*Math.sin(t*2.1));
      }
    }

    function lerpCards() {
      for (const card of cards) {
        const isFocus = (card === focused);
        const smooth = isFocus ? 0.18 : 0.10;
        card.position.lerp(card.userData.targetPos, smooth);
        card.quaternion.slerp(card.userData.targetQuat, smooth);
        const tScale = isFocus ? card.userData.targetScale : 1;
        const s = card.scale.x + (tScale - card.scale.x) * smooth;
        card.scale.setScalar(s);
      }
    }

    let lastT = performance.now();
    function tick() {
      requestAnimationFrame(tick);
      const now = performance.now();
      const dt = Math.min(0.033, (now - lastT) / 1000);
      lastT = now;
      const t = now * 0.001;

      if (mode === "WALL") scene.rotation.y += PARAM.idleRotate;

      updateSnow(dt);
      updateTreeFX(t);
      lerpCards();

      renderer.render(scene, camera);
    }
    tick();

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(devicePixelRatio || 1, 2));
      renderer.setSize(innerWidth, innerHeight);
    });

    setMode("INIT");
  </script>
</body>
</html>
